# Creating DFA from a Regular Expression

## Subject: Program reading regular expressions, constructing NFA using Thompson algorithm, converting NFA into DFA and validating input strings generated by this expression (working on DFA).

# General overview and assumptions

Main topic of my assignment is to create a program that creates ε-NFA form a given regular expression using Thomson algorithm. Then it constructs DFA from a given ε-NFA and validates the input strings. One of the assumptions is that I&#39;ll use the English letters as an input alphabet. Furthermore with regards to the regular expression&#39;s symbols I&#39;ll use &quot;\*&quot; as a symbol of Kleene&#39;s closure, &quot;|&quot; for union, concatenation is unmarked, thus I&#39;ll assume &quot;\x08&quot; (binary code to represent backspace character) as it&#39;s representation in my symbol table.

# Functional requirements

There are two inputs in my program. First one is the regular expression that uses symbols like: (\*, |, /x08, ) to represent all necessary conjunctions. The alphabet I&#39;ve used is English alphabet, thus any attempt to introduce other characters or symbols will result in ParseException being thrown. Second one is the input string ( or many input strings) that perform a walk over the DFA constructed form ε-NFA which we&#39;ve obtained form Thompson algorithm form a given regular expression.

# Implementation

Algorithm itself consists of several parts. In the first phase we separate characters into a groups of tokens. There are two type of tokens: letter which stands for input alphabet and symbol which represents special symbols used to describe regular expression. Each token has two fields: name and value. Scanner scans through a given regular expression and every time it&#39;s required it returns the next token on the input. Main part of this phase is Parser which creates token table that represents given regexp. This part is crucial because NFA and DFA will be constructed based on this table. Phase two creates the NFA using appropriate constructors defined in NFA\_constructor class. The last part of this algorithm is to create DFA form a given ε-NFA which we do by defining ε-closure and move function. In the end we validate our input string with walk() function to check if given regexp is accepting our input string.

**Parsing**

| Token |
| --- |
| _Name - Name of the token eg. CHAR or LEFT\_PAREN_ |
| _Value -_ _Value of the token eg. a or (_ |
| **\_\_init\_\_ - Init method** |
| **\_\_str\_\_ - Conjunction of name and value of a token eg. CHAR: a** |

| Scanner |
| --- |
| _Regexp -- Holds the input pattern of the regular expression_ |
| _Symbols - Symbol table defined for regular expressions_ |
| _Current - Points to current position in regexp_ |
| _Length - Total length of regular expression_ |
| _Alphabet - Defined alphabet of input words and regexps_ |
| **get\_token - Returns next token in line** |
| **show\_pattern - Presents regular expression** |

| Parser |
| --- |
| _Scanner - Holds the scanner that have regular expression_ |
| _token\_list - Stores created list of tokens form scanner&#39;s regexp_ |
| _lookahead\_pointer - Points to the next regex_ |
| **\_\_init\_\_(scanner) - Initialize class and set lookahead pointer to first char in regexp using get\_token method** |
| **shift(name) - Takes the supposed name of the token and sets lookahead pointer to next in line** |
| **Parse - Starts the &quot;recursion&quot; of the algorithm that creates token list and returns it** |
| **check\_union - Checks if the union is present. If so then memoraize it and dive deeper into regexp** |
| **check\_concat - Checks if characters are concatenated** |
| **check\_closure - Checks for Kleen&#39;s closure** |
| **check\_char - Searches for letter or left parentheesis** |
| **show\_token\_list - Prints token list** |

It&#39;s worth explaining here how the parser structure works. If we want to begging parsing process we have to call parse() function. It starts the entire cycle of creating token list in something similar to Reverse Polish Notation. Firstly diving down into functions the character or parenthesis is checked. If found then we add it to token list. First return from the check\_char function looks for kleen&#39;s closure appering after the character or right parenthesis. If found then we add it after character in token list if not then we proceed with return. Next one in line is concatenation. Last thing we look for is union character. If we won&#39;t find any of the mentioned above we return the token list. If we find some appropriate symbol we start our dive again.

**ε-NFA**

| NFA State |
| --- |
| _epsilon closure - List of state that have epsilon transition_ |
| _transition table -Dictionary with key being letter and value is nfa state_ |
| _Name - Name of the state eg. s2_ |
| _is\_final - Flag for marking the final state_ |
| _Start - Start state reference_ |
| _End - End State reference_ |
| **\_\_init\_\_ (name) - Initialize nfa\_state with given name** |
| **\_\_init\_\_ (start, end) - Initialize NFA with given start and end reference** |
| **show\_nfa - Prints the contets of NFA** |
| **pretty print - Recursive function for printing** |

| NFA Constructor |
| --- |
| _Constructors - Dictionary holding all functions under the key of token names_ |
| _State\_count - Counter of states in constructed NFA_ |
| **Nfa\_stack - A stack holding all constructed NFA** |
| **Construct\_state - Returns constructed state with name taken form state count eg. s6** |
| **Construct\_char - Creates two states adds transition to start and pushes created nfa onto the stack** |
| **Construc\_concat - Pops two nfa&#39;s and adds epsilon transition between end of the first and start of the second** |
| **Construct\_union - Pop two nfa&#39;s, create two states, add eps transiton from state1 to nfa&#39;s start and connect end&#39;s of nfa&#39;s with second state. Construct nfa from given states and push it onto the stack.** |
| **Construct\_star - Pop nfa form stack create two states and add appropriate eps transitions, create nfa and push it onto the stack** |
| **Construct\_nfa - Create nfa based on the token list, assert the stack is of length 1 if so pop first element** |

**DFA**

| DFA State |
| --- |
| _Nfa states - List of nfa states inside the dfa state_ |
| _Transition table - Dictionary with key being letter and value is dfa state_ |
| _Name - Name of the state eg. s2_ |
| _Is\_final - Flag for marking the final state_ |
| **\_\_init\_\_ (name) - Initialize dfa\_state with given name** |

| DFA |
| --- |
| _States - List of DFA states_ |
| **\_\_init\_\_ - Initialize DFA** |
| **check\_state(given\_states) - Take list of NFA states and return corresponding DFA state if it exists** |
| **walk\_dfa(word) - Perform a walk over DFA with a given word if it works on DFA then return True** |
| **show\_dfa - Print DFA** |
| **pretty\_print - Recursive Printing** |

| DFA Constructor |
| --- |
| _Alphabet - List of all characters defined in alphabet_ |
| _State\_count - Counter of states in constructed NFA_ |
| **\_\_init\_\_ - Initialize DFA constructor** |
| **Construct\_state - Returns constructed state with name taken form state count eg. DFA\_s6** |
| **Eps\_closure(states) - Perform epsilon closure on the list of states** |
| **Move - With a given state and letter performe move operation** |
| **Construct\_dfa - Create DFA and DFA state, perform eps closure on it and add it to list of states. For every state in list of states, perform move function for entire alphabet and then eps closure on this move function result. If the states with the resulting list exists add transition if not create such state and add transition.** |

# Execution of the program

To execute this program we need to do certain steps:

1. Define our regexp
2. Create scanner with a given regexp
3. Create parser with a defined scanner
4. Construct NFA form a token list given from the parser
5. Construct DFA from a nfa constructed by NFA Constructor
6. We can now perform a walk over DFA with given string

# Functional test cases

- Regex: a|b\* (Expected patterns: a, ε, b, bb, bbb,bbbb) Input: ab, a, aa, ba, bbbb.

Expected output: (False, True, True, False, True)

- Regex: (ab|aa)\* (Expected patterns: ε, ab, abab, aa, aaaa) Input: ababab, aaa, a, aa, bb

Expected output: (True, False, False, True, False)

- Regex: (cd\* | bha )\* jk (Expected patterns: cdjk, cdcdjk, bhabhajk, jk) Input: k, mf, jk, e, t

Expected output: (False, False, True, False, False)

- Regex: ytut (a | g)\* lk (Expected patterns: ytutalk, ytutglk, ytutaaaa,lk) Input: a, ytu, ytutalk

Expected output: (False, False, True)

- Regex: 01(&#39;=34567) Expected Result: ParseError detection!

- Regex: (\*) Expected pattern: ε Input: a, 4, 2656, Owsekb, ε

Expected output: (False, False, False, True)